/*
 * Copyright (c) 2020, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <cudf/ast/operators.hpp>
#include <cudf/scalar/scalar.hpp>
#include <cudf/scalar/scalar_device_view.cuh>
#include <cudf/table/table_view.hpp>
#include <cudf/types.hpp>
#include <cudf/utilities/error.hpp>

namespace cudf {

namespace ast {

/**
 * @brief Enum of table references.
 *
 * This determines which table to use in cases with two tables (e.g. joins).
 *
 */
enum class table_reference {
  LEFT,   // Column index in the left table
  RIGHT,  // Column index in the right table
  OUTPUT  // Column index in the output table
};

namespace detail {

/**
 * @brief Enum defining data reference types used by a node.
 *
 * This enum is device-specific. For instance, intermediate data references are generated by the
 * linearization process but cannot be explicitly created by the user.
 *
 */
enum class device_data_reference_type {
  COLUMN,       // A value in a table column
  LITERAL,      // A literal value
  INTERMEDIATE  // An internal temporary value
};

/**
 * @brief A device data reference describes a source of data used by a node.
 *
 * This is a POD class used to create references describing data type and locations for consumption
 * by the `row_evaluator`.
 *
 */
struct device_data_reference {
  device_data_reference_type reference_type;  // Source of data
  cudf::data_type data_type;                  // Type of data
  cudf::size_type
    data_index;  // The column index of a table, index of a literal, or index of an intermediate
  table_reference table_reference = table_reference::LEFT;

  inline bool operator==(const device_data_reference& rhs) const
  {
    return data_index == rhs.data_index && reference_type == rhs.reference_type &&
           table_reference == rhs.table_reference;
  }
};

/**
 * @brief Internal class used to track the utilization of intermediate storage locations.
 *
 * As nodes are being evaluated, they may generate "intermediate" data that is immediately
 * consumed. Rather than manifesting this data in global memory, we can store intermediates of any
 * fixed width type (up to 8 bytes) by placing them in shared memory. This class helps to track the
 * number and indices of intermediate data in shared memory using a give-take model. Locations
 * in shared memory can be "taken" and used for storage, "given back," and then later re-used. This
 * aims to minimize the maximum amount of shared memory needed at any point during the evaluation.
 *
 */
class intermediate_counter {
 public:
  intermediate_counter() : used_values(), max_used(0) {}
  cudf::size_type take();
  void give(cudf::size_type value);
  cudf::size_type get_max_used() const { return this->max_used; }

 private:
  cudf::size_type find_first_missing(cudf::size_type start, cudf::size_type end) const;
  std::vector<cudf::size_type> used_values;
  cudf::size_type max_used;
};

}  // namespace detail

// Forward declaration
class abstract_visitor;
class literal;
class column_reference;
class expression;

/**
 * @brief A generic node that can be evaluated to return a value.
 *
 * This class is a part of a "visitor" pattern with the `abstract_visitor` class.
 * Nodes inheriting from this class can accept visitors.
 *
 */
class node {
 public:
  virtual cudf::size_type accept(abstract_visitor& visitor) const = 0;
};

/**
 * @brief An abstract class capable of visiting nodes.
 *
 * This class is part of a "visitor" pattern with the `node` class.
 * Visitors inheriting from this class can visit nodes.
 *
 */
class abstract_visitor {
 public:
  virtual cudf::size_type visit(literal const& expr)          = 0;
  virtual cudf::size_type visit(column_reference const& expr) = 0;
  virtual cudf::size_type visit(expression const& expr)       = 0;
};

/**
 * @brief A literal value used in an abstract syntax tree.
 *
 */
class literal : public node {
 public:
  /**
   * @brief Construct a new literal object.
   *
   * @param value A fixed width scalar device view containing the literal value.
   */
  literal(const cudf::detail::fixed_width_scalar_device_view_base value) : value(value) {}

  /**
   * @brief Get the value object.
   *
   * @return cudf::detail::fixed_width_scalar_device_view_base
   */
  cudf::detail::fixed_width_scalar_device_view_base get_value() const { return this->value; }

  /**
   * @brief Get the data type.
   *
   * @return cudf::data_type
   */
  cudf::data_type get_data_type() const { return this->get_value().type(); }

  /**
   * @brief Accepts a visitor class.
   *
   * @param visitor Visitor.
   * @return cudf::size_type Index of device data reference for this instance.
   */
  cudf::size_type accept(abstract_visitor& visitor) const override { return visitor.visit(*this); }

 private:
  const cudf::detail::fixed_width_scalar_device_view_base value;
};

/**
 * @brief A node referring to data from a column in a table.
 *
 */
class column_reference : public node {
 public:
  /**
   * @brief Construct a new column reference object
   *
   * @param column_index Index of this column in the table (provided when the node is
   * evaluated).
   * @param table_source Which table to use in cases with two tables (e.g. joins).
   */
  column_reference(cudf::size_type column_index,
                   table_reference table_source = table_reference::LEFT)
    : column_index(column_index), table_source(table_source)
  {
  }

  /**
   * @brief Get the column index.
   *
   * @return cudf::size_type
   */
  cudf::size_type get_column_index() const { return this->column_index; }

  /**
   * @brief Get the table source.
   *
   * @return table_reference
   */
  table_reference get_table_source() const { return this->table_source; }

  /**
   * @brief Get the data type.
   *
   * @param table Table used to determine types.
   * @return cudf::data_type
   */
  cudf::data_type get_data_type(const table_view& table) const
  {
    return table.column(this->get_column_index()).type();
  }

  /**
   * @brief Get the data type.
   *
   * @param left_table Left table used to determine types.
   * @param right_table Right table used to determine types.
   * @return cudf::data_type
   */
  cudf::data_type get_data_type(const table_view& left_table, const table_view& right_table) const
  {
    const auto table = [&] {
      if (this->get_table_source() == table_reference::LEFT) {
        return left_table;
      } else if (this->get_table_source() == table_reference::RIGHT) {
        return right_table;
      } else {
        CUDF_FAIL("Column reference data type cannot be determined from unknown table.");
      }
    }();
    return table.column(this->get_column_index()).type();
  }

  /**
   * @brief Accepts a visitor class.
   *
   * @param visitor Visitor.
   * @return cudf::size_type Index of device data reference for this instance.
   */
  cudf::size_type accept(abstract_visitor& visitor) const override { return visitor.visit(*this); }

 private:
  cudf::size_type column_index;
  table_reference table_source;
};

/**
 * @brief An expression node holds an operator and zero or more operands.
 *
 */
class expression : public node {
 public:
  /**
   * @brief Construct a new unary expression object.
   *
   * @param op Operator
   * @param input Input node (operand)
   */
  expression(ast_operator op, node const& input) : op(op), operands({input})
  {
    if (cudf::ast::ast_operator_arity(op) != 1) {
      CUDF_FAIL("The provided operator is not a unary operator.");
    }
  }

  /**
   * @brief Construct a new binary expression object.
   *
   * @param op Operator
   * @param left Left input node (left operand)
   * @param right Right input node (right operand)
   */
  expression(ast_operator op, node const& left, node const& right) : op(op), operands({left, right})
  {
    if (cudf::ast::ast_operator_arity(op) != 2) {
      CUDF_FAIL("The provided operator is not a binary operator.");
    }
  }

  /**
   * @brief Get the operator.
   *
   * @return ast_operator
   */
  ast_operator get_operator() const { return this->op; }

  /**
   * @brief Get the operands.
   *
   * @return std::vector<std::reference_wrapper<const node>>
   */
  std::vector<std::reference_wrapper<const node>> get_operands() const { return this->operands; }

  /**
   * @brief Accepts a visitor class.
   *
   * @param visitor Visitor.
   * @return cudf::size_type Index of device data reference for this instance.
   */
  cudf::size_type accept(abstract_visitor& visitor) const override { return visitor.visit(*this); }

 private:
  const ast_operator op;
  const std::vector<std::reference_wrapper<const node>> operands;
};

/**
 * @brief The linearizer traverses an abstract syntax tree to prepare for execution on the device.
 *
 * This class does pre-processing work on the host, validating operators and operand data types. It
 * traverses downward from a root node in a depth-first fashion, capturing information about
 * the nodes and constructing vectors of information that are later used by the device for
 * evaluating the abstract syntax tree as a "linear" list of operators whose input dependencies are
 * resolved into intermediate data storage in shared memory.
 *
 */
class linearizer : public abstract_visitor {
 public:
  /**
   * @brief Construct a new linearizer object
   *
   * @param table The table used for evaluating the abstract syntax tree.
   */
  linearizer(node const& expr, cudf::table_view table)
    : table(table), node_count(0), intermediate_counter()
  {
    expr.accept(*this);
  }

  /**
   * @brief Get the root data type of the abstract syntax tree.
   *
   * @return cudf::data_type
   */
  cudf::data_type get_root_data_type() const;

  /**
   * @brief Get the maximum number of intermediates stored by the abstract syntax tree.
   *
   * @return cudf::size_type
   */
  cudf::size_type get_intermediate_count() const
  {
    return this->intermediate_counter.get_max_used();
  }

  /**
   * @brief Get the device data references.
   *
   * @return std::vector<detail::device_data_reference>
   */
  std::vector<detail::device_data_reference> get_data_references() const
  {
    return this->data_references;
  }

  /**
   * @brief Get the operators.
   *
   * @return std::vector<ast_operator>
   */
  std::vector<ast_operator> get_operators() const { return this->operators; }

  /**
   * @brief Get the operator source indices.
   *
   * @return std::vector<cudf::size_type>
   */
  std::vector<cudf::size_type> get_operator_source_indices() const
  {
    return this->operator_source_indices;
  }

  /**
   * @brief Get the literal device views.
   *
   * @return std::vector<cudf::detail::fixed_width_scalar_device_view_base>
   */
  std::vector<cudf::detail::fixed_width_scalar_device_view_base> get_literals() const
  {
    return this->literals;
  }

 private:
  /**
   * @brief Visit a literal node.
   *
   * @param expr Literal node.
   * @return cudf::size_type Index of device data reference for the node.
   */
  cudf::size_type visit(literal const& expr) override;

  /**
   * @brief Visit a column reference node.
   *
   * @param expr Column reference node.
   * @return cudf::size_type Index of device data reference for the node.
   */
  cudf::size_type visit(column_reference const& expr) override;

  /**
   * @brief Visit an expression node.
   *
   * @param expr Expression node.
   * @return cudf::size_type Index of device data reference for the node.
   */
  cudf::size_type visit(expression const& expr) override;

  std::vector<cudf::size_type> visit_operands(
    std::vector<std::reference_wrapper<const node>> operands);
  cudf::size_type add_data_reference(detail::device_data_reference data_ref);

  // State information about the "linearized" GPU execution plan
  cudf::table_view table;
  cudf::size_type node_count;
  detail::intermediate_counter intermediate_counter;
  std::vector<detail::device_data_reference> data_references;
  std::vector<ast_operator> operators;
  std::vector<cudf::size_type> operator_source_indices;
  std::vector<cudf::detail::fixed_width_scalar_device_view_base> literals;
};

}  // namespace ast

}  // namespace cudf
